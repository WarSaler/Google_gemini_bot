import os
import logging
import asyncio
import base64
import tempfile
from datetime import datetime, timedelta
from collections import defaultdict, deque
from typing import Dict, List, Optional
import aiohttp
from io import BytesIO
import speech_recognition as sr
from pydub import AudioSegment

from telegram import Update, Bot
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from telegram.constants import ParseMode
from keep_alive import start_server

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN')
AI_API_KEY = os.getenv('AI_API_KEY')
GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent'

# –õ–∏–º–∏—Ç—ã –∑–∞–ø—Ä–æ—Å–æ–≤ (–æ—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–µ –ª–∏–º–∏—Ç—ã Google Gemini 2.5 Flash Free Tier)
MINUTE_LIMIT = 10  # 10 –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –º–∏–Ω—É—Ç—É
DAILY_LIMIT = 250  # 250 –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –¥–µ–Ω—å

# –•—Ä–∞–Ω–∏–ª–∏—â–µ –¥–∞–Ω–Ω—ã—Ö
user_sessions: Dict[int, deque] = defaultdict(lambda: deque(maxlen=50))
request_counts: Dict[int, Dict[str, List[datetime]]] = defaultdict(lambda: {'minute': [], 'day': []})

class GeminiBot:
    def __init__(self):
        self.bot = None
        
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ö–æ–º–∞–Ω–¥–∞ /start"""
        user_id = update.effective_user.id
        welcome_message = """ü§ñ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Gemini Bot!

–Ø –º–æ–≥—É –ø–æ–º–æ—á—å –≤–∞–º —Å:
‚Ä¢ üí¨ –û—Ç–≤–µ—Ç–∞–º–∏ –Ω–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –≤–æ–ø—Ä–æ—Å—ã
‚Ä¢ üé§ –û–±—Ä–∞–±–æ—Ç–∫–æ–π –≥–æ–ª–æ—Å–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π (—Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ —Ä–µ—á–∏)
‚Ä¢ üñºÔ∏è –ê–Ω–∞–ª–∏–∑–æ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π (–ù–ï —Å–æ–∑–¥–∞—é –∫–∞—Ä—Ç–∏–Ω–∫–∏!)
‚Ä¢ üíª –†–∞–±–æ—Ç–æ–π —Å –∫–æ–¥–æ–º

–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:
/start - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
/help - –°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º  
/clear - –û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é —á–∞—Ç–∞
/limits - –ü–æ–∫–∞–∑–∞—Ç—å –ª–∏–º–∏—Ç—ã –∑–∞–ø—Ä–æ—Å–æ–≤

‚ö†Ô∏è –í–ê–ñ–ù–û: –Ø –º–æ–≥—É —Ç–æ–ª—å–∫–æ –∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏ —Ä–∞—Å—Å–∫–∞–∑–∞—Ç—å —á—Ç–æ –Ω–∞ –Ω–∏—Ö, –Ω–æ –ù–ï –ú–û–ì–£ —Å–æ–∑–¥–∞–≤–∞—Ç—å –∏–ª–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫–∏!

–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ –º–Ω–µ —Ç–µ–∫—Å—Ç, –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–ª–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ, –∏ —è –ø–æ–º–æ–≥—É –≤–∞–º!"""
        
        await update.message.reply_text(welcome_message)
        
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ö–æ–º–∞–Ω–¥–∞ /help"""
        help_message = """üìã –°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º:

/start - –ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –∏ –æ—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É
/clear - –û—á–∏—Å—Ç–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é –ø–µ—Ä–µ–ø–∏—Å–∫–∏ (–±–æ—Ç –∑–∞–±—É–¥–µ—Ç –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è)
/limits - –ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â–∏–µ –ª–∏–º–∏—Ç—ã –∑–∞–ø—Ä–æ—Å–æ–≤

üîÑ –ö–∞–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è:
‚Ä¢ –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ—Ç–≤–µ—Ç–∞
‚Ä¢ üé§ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –≥–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ - —è —Ä–∞—Å—à–∏—Ñ—Ä—É—é —Ä–µ—á—å –∏ –æ—Ç–≤–µ—á—É
‚Ä¢ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –ø–æ–¥–ø–∏—Å—å—é –∏–ª–∏ –±–µ–∑ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
‚Ä¢ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –∫–æ–¥ –¥–ª—è –µ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –∏–ª–∏ –æ–±—ä—è—Å–Ω–µ–Ω–∏—è

‚ö†Ô∏è –í–ê–ñ–ù–û –ø—Ä–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:
‚Ä¢ –Ø –ê–ù–ê–õ–ò–ó–ò–†–£–Æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (–æ–ø–∏—Å—ã–≤–∞—é —á—Ç–æ –≤–∏–∂—É)
‚Ä¢ –Ø –ù–ï –°–û–ó–î–ê–Æ –Ω–æ–≤—ã–µ –∫–∞—Ä—Ç–∏–Ω–∫–∏ –∏–ª–∏ —Ñ–æ—Ç–æ
‚Ä¢ –Ø –ù–ï –†–ï–î–ê–ö–¢–ò–†–£–Æ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è

üé§ –í–ê–ñ–ù–û –ø—Ä–æ –≥–æ–ª–æ—Å–æ–≤—ã–µ:
‚Ä¢ –Ø –†–ê–°–®–ò–§–†–û–í–´–í–ê–Æ –≤–∞—à–∏ –≥–æ–ª–æ—Å–æ–≤—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Ç–µ–∫—Å—Ç
‚Ä¢ –û—Ç–≤–µ—á–∞—é —Ç–µ–∫—Å—Ç–æ–º –Ω–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
‚Ä¢ –†–∞–±–æ—Ç–∞—é —Å —Ä—É—Å—Å–∫–∏–º –∏ –∞–Ω–≥–ª–∏–π—Å–∫–∏–º —è–∑—ã–∫–∞–º–∏

‚ö° –õ–∏–º–∏—Ç—ã:
‚Ä¢ 10 –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –º–∏–Ω—É—Ç—É
‚Ä¢ 250 –∑–∞–ø—Ä–æ—Å–æ–≤ –≤ –¥–µ–Ω—å

–ò—Å—Ç–æ—Ä–∏—è —á–∞—Ç–∞ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è (–ø–æ—Å–ª–µ–¥–Ω–∏–µ 50 —Å–æ–æ–±—â–µ–Ω–∏–π) –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Ä–∞–∑–≥–æ–≤–æ—Ä–∞."""
        
        await update.message.reply_text(help_message)
        
    async def clear_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ö–æ–º–∞–Ω–¥–∞ /clear"""
        user_id = update.effective_user.id
        user_sessions[user_id].clear()
        await update.message.reply_text("üóëÔ∏è –ò—Å—Ç–æ—Ä–∏—è —á–∞—Ç–∞ –æ—á–∏—â–µ–Ω–∞! –Ø –∑–∞–±—ã–ª –≤—Å–µ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è.")
        
    async def limits_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ö–æ–º–∞–Ω–¥–∞ /limits"""
        user_id = update.effective_user.id
        remaining_minute, remaining_day = self.get_remaining_requests(user_id)
        
        limits_message = f"""üìä –í–∞—à–∏ —Ç–µ–∫—É—â–∏–µ –ª–∏–º–∏—Ç—ã:

üïê –í —ç—Ç–æ–π –º–∏–Ω—É—Ç–µ: {remaining_minute}/{MINUTE_LIMIT}
üìÖ –°–µ–≥–æ–¥–Ω—è: {remaining_day}/{DAILY_LIMIT}

–õ–∏–º–∏—Ç—ã –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏."""
        
        await update.message.reply_text(limits_message)

    def clean_old_requests(self, user_id: int):
        """–û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤"""
        now = datetime.now()
        minute_ago = now - timedelta(minutes=1)
        day_ago = now - timedelta(days=1)
        
        # –û—á–∏—Å—Ç–∫–∞ –º–∏–Ω—É—Ç–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
        request_counts[user_id]['minute'] = [
            req_time for req_time in request_counts[user_id]['minute'] 
            if req_time > minute_ago
        ]
        
        # –û—á–∏—Å—Ç–∫–∞ –¥–Ω–µ–≤–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
        request_counts[user_id]['day'] = [
            req_time for req_time in request_counts[user_id]['day'] 
            if req_time > day_ago
        ]

    def get_remaining_requests(self, user_id: int) -> tuple:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è –∑–∞–ø—Ä–æ—Å–æ–≤"""
        self.clean_old_requests(user_id)
        
        minute_count = len(request_counts[user_id]['minute'])
        day_count = len(request_counts[user_id]['day'])
        
        remaining_minute = max(0, MINUTE_LIMIT - minute_count)
        remaining_day = max(0, DAILY_LIMIT - day_count)
        
        return remaining_minute, remaining_day

    def can_make_request(self, user_id: int) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —Å–¥–µ–ª–∞—Ç—å –∑–∞–ø—Ä–æ—Å"""
        remaining_minute, remaining_day = self.get_remaining_requests(user_id)
        return remaining_minute > 0 and remaining_day > 0

    def add_request(self, user_id: int):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞ –≤ —Å—á–µ—Ç—á–∏–∫"""
        now = datetime.now()
        request_counts[user_id]['minute'].append(now)
        request_counts[user_id]['day'].append(now)

    async def call_gemini_api(self, messages: List[dict]) -> Optional[str]:
        """–í—ã–∑–æ–≤ API Gemini"""
        headers = {
            'Content-Type': 'application/json',
        }
        
        payload = {
            'contents': [
                {
                    'parts': messages
                }
            ],
            'generationConfig': {
                'temperature': 0.7,
                'topK': 40,
                'topP': 0.95,
                'maxOutputTokens': 2048,
            }
        }
        
        try:
            async with aiohttp.ClientSession() as session:
                logger.debug(f"Sending request to Gemini API...")
                async with session.post(
                    f"{GEMINI_API_URL}?key={AI_API_KEY}",
                    headers=headers,
                    json=payload
                ) as response:
                    logger.debug(f"Gemini API responded with status: {response.status}")
                    if response.status == 200:
                        data = await response.json()
                        if 'candidates' in data and len(data['candidates']) > 0:
                            result = data['candidates'][0]['content']['parts'][0]['text']
                            logger.info(f"Gemini API success: received {len(result)} characters")
                            return result
                        else:
                            logger.error(f"Gemini API: No candidates in response. Full response: {data}")
                            return None
                    else:
                        error_text = await response.text()
                        logger.error(f"Gemini API Error: {response.status}")
                        logger.error(f"Error details: {error_text}")
                        return None
        except Exception as e:
            logger.error(f"Exception calling Gemini API: {e}")
            logger.error(f"Exception type: {type(e).__name__}")
            return None

    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        user_id = update.effective_user.id
        message_text = update.message.text
        
        logger.info(f"Received message from user {user_id}: {message_text[:100]}...")
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–æ–≤
        if not self.can_make_request(user_id):
            remaining_minute, remaining_day = self.get_remaining_requests(user_id)
            await update.message.reply_text(
                f"‚ùå –ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤!\n\n–û—Å—Ç–∞–ª–æ—Å—å –∑–∞–ø—Ä–æ—Å–æ–≤: {remaining_minute}/{MINUTE_LIMIT} –≤ —ç—Ç–æ–π –º–∏–Ω—É—Ç–µ, {remaining_day}/{DAILY_LIMIT} —Å–µ–≥–æ–¥–Ω—è."
            )
            return

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Å—Å–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        if user_id not in user_sessions:
            user_sessions[user_id] = []

        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –∏—Å—Ç–æ—Ä–∏—é
        user_sessions[user_id].append({
            'role': 'user',
            'content': message_text,
            'timestamp': datetime.now()
        })

        # –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –∏—Å—Ç–æ—Ä–∏–∏
        if len(user_sessions[user_id]) > 100:  # 50 –ø–∞—Ä —Å–æ–æ–±—â–µ–Ω–∏–π
            user_sessions[user_id] = user_sessions[user_id][-100:]

        # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è API
        messages = []
        for msg in user_sessions[user_id]:
            if msg['role'] == 'user':
                messages.append({'text': msg['content']})
            elif msg['role'] == 'assistant':
                messages.append({'text': f"Assistant: {msg['content']}"})

        # –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–∞–±–æ—Ä–∞
        try:
            await context.bot.send_chat_action(chat_id=update.effective_chat.id, action='typing')
            logger.info(f"Sent typing indicator for user {user_id}")
        except Exception as e:
            logger.warning(f"Could not send typing indicator for user {user_id}: {e}")

        # –í—ã–∑–æ–≤ API
        logger.info(f"Calling Gemini API for user {user_id} with {len(messages)} messages")
        response = await self.call_gemini_api(messages)
        
        if response:
            logger.info(f"Received response from Gemini API for user {user_id}: {len(response)} characters")
            # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞ –≤ —Å—á–µ—Ç—á–∏–∫
            self.add_request(user_id)
            
            # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞ –≤ –∏—Å—Ç–æ—Ä–∏—é
            user_sessions[user_id].append({
                'role': 'assistant',
                'content': response,
                'timestamp': datetime.now()
            })
            
            # –ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è –∑–∞–ø—Ä–æ—Å–æ–≤
            remaining_minute, remaining_day = self.get_remaining_requests(user_id)
            
            # –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞ —Å –±–µ–∑–æ–ø–∞—Å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π
            await self.safe_send_message(update, response, remaining_minute, remaining_day, user_id)
        else:
            logger.error(f"No response received from Gemini API for user {user_id}")
            await self.safe_send_message(update, "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ AI. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", None, None, user_id)

    async def safe_send_message(self, update: Update, response: str, remaining_minute: int = None, remaining_day: int = None, user_id: int = None):
        """–ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —Å –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ fallback –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏"""
        try:
            # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–ª–Ω–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
            if remaining_minute is not None and remaining_day is not None:
                full_response = f"{response}\n\nüìä –û—Å—Ç–∞–ª–æ—Å—å –∑–∞–ø—Ä–æ—Å–æ–≤: {remaining_minute}/{MINUTE_LIMIT} –≤ —ç—Ç–æ–π –º–∏–Ω—É—Ç–µ, {remaining_day}/{DAILY_LIMIT} —Å–µ–≥–æ–¥–Ω—è."
            else:
                full_response = response
            
            # –ü–æ–ø—ã—Ç–∫–∞ 1: –æ—Ç–ø—Ä–∞–≤–∫–∞ –∫–∞–∫ –µ—Å—Ç—å (–±–µ–∑ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞)
            try:
                await update.message.reply_text(full_response)
                logger.info(f"Message sent successfully to user {user_id}")
                return
            except Exception as e:
                logger.warning(f"First send attempt failed for user {user_id}: {e}")
            
            # –ü–æ–ø—ã—Ç–∫–∞ 2: –±–µ–∑ —ç–º–æ–¥–∑–∏
            try:
                if remaining_minute is not None and remaining_day is not None:
                    simple_response = f"{response}\n\n–û—Å—Ç–∞–ª–æ—Å—å –∑–∞–ø—Ä–æ—Å–æ–≤: {remaining_minute}/{MINUTE_LIMIT} –≤ —ç—Ç–æ–π –º–∏–Ω—É—Ç–µ, {remaining_day}/{DAILY_LIMIT} —Å–µ–≥–æ–¥–Ω—è."
                else:
                    simple_response = response
                await update.message.reply_text(simple_response)
                logger.info(f"Message sent successfully (without emoji) to user {user_id}")
                return
            except Exception as e:
                logger.warning(f"Second send attempt failed for user {user_id}: {e}")
            
            # –ü–æ–ø—ã—Ç–∫–∞ 3: —Ç–æ–ª—å–∫–æ –æ—Å–Ω–æ–≤–Ω–æ–π –æ—Ç–≤–µ—Ç
            try:
                await update.message.reply_text(response)
                logger.info(f"Message sent successfully (response only) to user {user_id}")
                return
            except Exception as e:
                logger.warning(f"Third send attempt failed for user {user_id}: {e}")
            
            # –ü–æ–ø—ã—Ç–∫–∞ 4: —ç–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç
            try:
                escaped_response = response.replace('.', '\\.')
                await update.message.reply_text(escaped_response)
                logger.info(f"Message sent successfully (escaped) to user {user_id}")
                return
            except Exception as e:
                logger.warning(f"Fourth send attempt failed for user {user_id}: {e}")
            
            # –ü–æ–ø—ã—Ç–∫–∞ 5: –∫—Ä–∞–π–Ω–∏–π —Å–ª—É—á–∞–π - –æ–±—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
            await update.message.reply_text("–û—Ç–≤–µ—Ç –ø–æ–ª—É—á–µ–Ω, –Ω–æ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.")
            logger.error(f"All send attempts failed for user {user_id}, sent generic error message")
            
        except Exception as e:
            logger.error(f"Critical error in safe_send_message for user {user_id}: {e}")

    async def handle_photo(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π"""
        user_id = update.effective_user.id
        
        logger.info(f"Received photo from user {user_id}")
        
        # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–æ–≤
        if not self.can_make_request(user_id):
            remaining_minute, remaining_day = self.get_remaining_requests(user_id)
            await update.message.reply_text(
                f"‚ùå –ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤!\n\n–û—Å—Ç–∞–ª–æ—Å—å –∑–∞–ø—Ä–æ—Å–æ–≤: {remaining_minute}/{MINUTE_LIMIT} –≤ —ç—Ç–æ–π –º–∏–Ω—É—Ç–µ, {remaining_day}/{DAILY_LIMIT} —Å–µ–≥–æ–¥–Ω—è."
            )
            return

        try:
            # –ü–æ–∫–∞–∑–∞—Ç—å –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–∞–±–æ—Ä–∞
            await context.bot.send_chat_action(chat_id=update.effective_chat.id, action='typing')
            
            # –ü–æ–ª—É—á–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
            photo_file = await update.message.photo[-1].get_file()
            photo_bytes = await photo_file.download_as_bytearray()
            
            # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –≤ base64
            photo_base64 = base64.b64encode(photo_bytes).decode('utf-8')
            
            # –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–¥–ø–∏—Å–∏ –∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—é
            caption = update.message.caption or "–ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π —ç—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"
            
            # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è API
            messages = [
                {'text': caption},
                {
                    'inline_data': {
                        'mime_type': 'image/jpeg',
                        'data': photo_base64
                    }
                }
            ]
            
            # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –∏—Å—Ç–æ—Ä–∏—é
            user_sessions[user_id].append({
                'role': 'user',
                'content': f"[–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ] {caption}",
                'timestamp': datetime.now()
            })

            # –í—ã–∑–æ–≤ API
            logger.info(f"Calling Gemini API for image analysis from user {user_id}")
            response = await self.call_gemini_api(messages)
            
            if response:
                logger.info(f"Received image analysis response for user {user_id}: {len(response)} characters")
                
                # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞ –≤ —Å—á–µ—Ç—á–∏–∫
                self.add_request(user_id)
                
                # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞ –≤ –∏—Å—Ç–æ—Ä–∏—é
                user_sessions[user_id].append({
                    'role': 'assistant',
                    'content': response,
                    'timestamp': datetime.now()
                })
                
                # –ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è –∑–∞–ø—Ä–æ—Å–æ–≤
                remaining_minute, remaining_day = self.get_remaining_requests(user_id)
                
                # –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞
                await self.safe_send_message(update, response, remaining_minute, remaining_day, user_id)
            else:
                logger.error(f"No response received from Gemini API for image analysis from user {user_id}")
                await self.safe_send_message(update, "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", None, None, user_id)
                
        except Exception as e:
            logger.error(f"Error handling photo from user {user_id}: {e}")
            await self.safe_send_message(update, "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.", None, None, user_id)

    async def speech_to_text(self, audio_bytes: bytes) -> Optional[str]:
        """–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –∞—É–¥–∏–æ –≤ —Ç–µ–∫—Å—Ç"""
        try:
            # –°–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
            with tempfile.NamedTemporaryFile(suffix=".ogg", delete=False) as ogg_file:
                ogg_file.write(audio_bytes)
                ogg_path = ogg_file.name
            
            with tempfile.NamedTemporaryFile(suffix=".wav", delete=False) as wav_file:
                wav_path = wav_file.name
            
            try:
                # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è OGG –≤ WAV —Å –ø–æ–º–æ—â—å—é pydub
                logger.debug("Converting OGG to WAV...")
                audio = AudioSegment.from_ogg(ogg_path)
                audio = audio.set_frame_rate(16000).set_channels(1)  # –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–ª—è —Ä–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏—è
                audio.export(wav_path, format="wav")
                
                # –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏
                logger.debug("Recognizing speech...")
                recognizer = sr.Recognizer()
                
                with sr.AudioFile(wav_path) as source:
                    audio_data = recognizer.record(source)
                
                # –ü—Ä–æ–±—É–µ–º —Å–Ω–∞—á–∞–ª–∞ —Ä—É—Å—Å–∫–∏–π, –ø–æ—Ç–æ–º –∞–Ω–≥–ª–∏–π—Å–∫–∏–π
                try:
                    text = recognizer.recognize_google(audio_data, language="ru-RU")
                    logger.info(f"Speech recognized (Russian): {len(text)} characters")
                    return text
                except sr.UnknownValueError:
                    # –ï—Å–ª–∏ —Ä—É—Å—Å–∫–∏–π –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª, –ø—Ä–æ–±—É–µ–º –∞–Ω–≥–ª–∏–π—Å–∫–∏–π
                    try:
                        text = recognizer.recognize_google(audio_data, language="en-US")
                        logger.info(f"Speech recognized (English): {len(text)} characters")
                        return text
                    except sr.UnknownValueError:
                        logger.warning("Could not understand audio in both Russian and English")
                        return None
                        
            finally:
                # –û—á–∏—Å—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤
                try:
                    os.unlink(ogg_path)
                    os.unlink(wav_path)
                except:
                    pass
                    
        except Exception as e:
            logger.error(f"Error in speech recognition: {e}")
            return None

    async def handle_voice(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ–ª–æ—Å–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
        user_id = update.effective_user.id
        logger.info(f"Received voice message from user {user_id}")
        
        try:
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ª–∏–º–∏—Ç–æ–≤
            if not self.can_make_request(user_id):
                remaining_minute, remaining_day = self.get_remaining_requests(user_id)
                await update.message.reply_text(
                    f"‚ùå –ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤!\n\n–û—Å—Ç–∞–ª–æ—Å—å –∑–∞–ø—Ä–æ—Å–æ–≤: {remaining_minute}/{MINUTE_LIMIT} –≤ —ç—Ç–æ–π –º–∏–Ω—É—Ç–µ, {remaining_day}/{DAILY_LIMIT} —Å–µ–≥–æ–¥–Ω—è."
                )
                return

            # –û—Ç–ø—Ä–∞–≤–∫–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –ø–µ—á–∞—Ç–∏
            await context.bot.send_chat_action(chat_id=update.effective_chat.id, action="typing")
            logger.info(f"Sent typing indicator for voice processing from user {user_id}")
            
            # –ü–æ–ª—É—á–µ–Ω–∏–µ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Ñ–∞–π–ª–∞
            voice_file = await update.message.voice.get_file()
            voice_bytes = await voice_file.download_as_bytearray()
            
            logger.info(f"Downloaded voice message: {len(voice_bytes)} bytes")
            
            # –†–∞—Å–ø–æ–∑–Ω–∞–≤–∞–Ω–∏–µ —Ä–µ—á–∏
            await update.message.reply_text("üé§ –†–∞—Å–ø–æ–∑–Ω–∞—é —Ä–µ—á—å...")
            transcribed_text = await self.speech_to_text(bytes(voice_bytes))
            
            if not transcribed_text:
                await self.safe_send_message(update, "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å —Ä–µ—á—å. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –≥–æ–≤–æ—Ä–∏—Ç–µ —á–µ—Ç—á–µ.", None, None, user_id)
                return
            
            logger.info(f"Voice transcribed for user {user_id}: {transcribed_text[:100]}...")
            
            # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏ –≤ –∏—Å—Ç–æ—Ä–∏—é
            user_sessions[user_id].append({
                'role': 'user',
                'content': f"[–ì–æ–ª–æ—Å–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ]: {transcribed_text}",
                'timestamp': datetime.now()
            })

            # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è Gemini API
            messages = [{'text': transcribed_text}]
            
            # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏
            for session_msg in list(user_sessions[user_id])[-10:]:  # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–æ–æ–±—â–µ–Ω–∏–π
                if session_msg['role'] == 'user':
                    messages.insert(0, {'text': f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: {session_msg['content']}"})
                else:
                    messages.insert(0, {'text': f"–ê—Å—Å–∏—Å—Ç–µ–Ω—Ç: {session_msg['content']}"})

            # –û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Ç–æ–º, —á—Ç–æ —Ä–µ—á—å —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–∞
            await update.message.reply_text(f"‚úÖ –†–∞—Å–ø–æ–∑–Ω–∞–Ω–æ: \"{transcribed_text}\"\n\nüí≠ –î—É–º–∞—é –Ω–∞–¥ –æ—Ç–≤–µ—Ç–æ–º...")
            
            logger.info(f"Calling Gemini API for voice message from user {user_id}")
            response = await self.call_gemini_api(messages)
            
            if response:
                logger.info(f"Received response from Gemini API for voice message from user {user_id}: {len(response)} characters")
                
                # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞ –≤ —Å—á–µ—Ç—á–∏–∫
                self.add_request(user_id)
                
                # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞ –≤ –∏—Å—Ç–æ—Ä–∏—é
                user_sessions[user_id].append({
                    'role': 'assistant',
                    'content': response,
                    'timestamp': datetime.now()
                })
                
                # –ü–æ–ª—É—á–µ–Ω–∏–µ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è –∑–∞–ø—Ä–æ—Å–æ–≤
                remaining_minute, remaining_day = self.get_remaining_requests(user_id)
                
                # –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—Ç–≤–µ—Ç–∞ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω–Ω–æ–π —Ä–µ—á–∏
                full_response = f"üé§ **–í–∞—à–µ —Å–æ–æ–±—â–µ–Ω–∏–µ:** {transcribed_text}\n\nüìù **–ú–æ–π –æ—Ç–≤–µ—Ç:** {response}"
                await self.safe_send_message(update, full_response, remaining_minute, remaining_day, user_id)
            else:
                logger.error(f"No response received from Gemini API for voice message from user {user_id}")
                await self.safe_send_message(update, "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞—â–µ–Ω–∏–∏ –∫ AI. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", None, None, user_id)
                
        except Exception as e:
            logger.error(f"Error handling voice message from user {user_id}: {e}")
            await self.safe_send_message(update, "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≥–æ–ª–æ—Å–æ–≤–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è.", None, None, user_id)

    def is_markdown(self, text: str) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è markdown –≤ —Ç–µ–∫—Å—Ç–µ (–Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è)"""
        # –§—É–Ω–∫—Ü–∏—è –æ—Å—Ç–∞–≤–ª–µ–Ω–∞ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏, –Ω–æ –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è
        return False

async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫"""
    import traceback
    
    error_msg = f"Exception while handling an update: {context.error}"
    
    # –°–ø–µ—Ü–∏–∞–ª—å–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–ª—è –∫–æ–Ω—Ñ–ª–∏–∫—Ç–∞ —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤
    if "Conflict" in str(context.error) and "getUpdates" in str(context.error):
        logger.error("CONFLICT DETECTED: Multiple bot instances running!")
        logger.error("This usually means:")
        logger.error("1. Bot is running locally while also on Render")
        logger.error("2. Multiple Render deployments with same token")
        logger.error("3. Webhook was not properly cleared")
        return
    
    logger.error(error_msg)
    logger.error(f"Traceback: {traceback.format_exc()}")
    
    # –ï—Å–ª–∏ –µ—Å—Ç—å update, –ª–æ–≥–∏—Ä—É–µ–º –µ–≥–æ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    if update:
        logger.error(f"Update that caused error: {update}")

async def watchdog():
    """–§—É–Ω–∫—Ü–∏—è watchdog –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∑–¥–æ—Ä–æ–≤—å—è –±–æ—Ç–∞ –∏ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –∑–∞—Å—ã–ø–∞–Ω–∏—è"""
    start_time = datetime.now()
    last_activity = datetime.now()
    
    while True:
        try:
            await asyncio.sleep(180)  # –ö–∞–∂–¥—ã–µ 3 –º–∏–Ω—É—Ç—ã
            
            current_time = datetime.now()
            uptime = current_time - start_time
            
            # –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –∑–∞—Å—ã–ø–∞–Ω–∏—è
            logger.info(f"üîç Bot Watchdog: Uptime {uptime}, Last activity: {current_time}")
            logger.info(f"üìä Active users: {len(user_sessions)}, Total request counters: {len(request_counts)}")
            
            # –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –ø–∞–º—è—Ç–∏
            if current_time.minute % 10 == 0:  # –ö–∞–∂–¥—ã–µ 10 –º–∏–Ω—É—Ç
                logger.info("üßπ Cleaning old session data...")
                cleanup_old_data()
                
        except Exception as e:
            logger.error(f"Watchdog error: {e}")

def cleanup_old_data():
    """–û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö —Å–µ—Å—Å–∏–π"""
    now = datetime.now()
    cutoff = now - timedelta(hours=24)
    
    # –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö —Å–µ—Å—Å–∏–π
    users_to_remove = []
    for user_id, session in user_sessions.items():
        if session and len(session) > 0:
            # –ï—Å–ª–∏ –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—á–µ–Ω—å —Å—Ç–∞—Ä–æ–µ, —É–¥–∞–ª—è–µ–º —Å–µ—Å—Å–∏—é
            try:
                if session[-1].get('timestamp', now) < cutoff:
                    users_to_remove.append(user_id)
            except (AttributeError, IndexError):
                # –ï—Å–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è, –æ—á–∏—â–∞–µ–º
                users_to_remove.append(user_id)
    
    for user_id in users_to_remove:
        del user_sessions[user_id]
        logger.debug(f"Cleaned old session for user {user_id}")
    
    if users_to_remove:
        logger.info(f"üßπ Cleaned {len(users_to_remove)} old user sessions")

async def run_bot():
    """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
    if not TELEGRAM_TOKEN or not AI_API_KEY:
        logger.error("Missing required environment variables: TELEGRAM_TOKEN or AI_API_KEY")
        return
    
    # –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    application = Application.builder().token(TELEGRAM_TOKEN).build()
    bot = GeminiBot()
    
    # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
    application.add_handler(CommandHandler("start", bot.start_command))
    application.add_handler(CommandHandler("help", bot.help_command))
    application.add_handler(CommandHandler("clear", bot.clear_command))
    application.add_handler(CommandHandler("limits", bot.limits_command))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, bot.handle_message))
    application.add_handler(MessageHandler(filters.PHOTO, bot.handle_photo))
    application.add_handler(MessageHandler(filters.VOICE, bot.handle_voice))
    application.add_error_handler(error_handler)
    
    # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
    logger.info("Starting bot...")
    await application.initialize()
    await application.start()
    
    # –ê–≥—Ä–µ—Å—Å–∏–≤–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ webhook –∏ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π
    logger.info("Performing aggressive webhook cleanup...")
    cleanup_attempts = 5
    for attempt in range(cleanup_attempts):
        try:
            logger.info(f"Webhook cleanup attempt {attempt + 1}/{cleanup_attempts}")
            await application.bot.delete_webhook(drop_pending_updates=True)
            await asyncio.sleep(2)
            
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø–æ–ø—ã—Ç–∫–∞ –æ—á–∏—Å—Ç–∫–∏
            await application.bot.delete_webhook()
            await asyncio.sleep(1)
            
            logger.info(f"Webhook cleanup attempt {attempt + 1} completed")
            break
        except Exception as e:
            logger.warning(f"Webhook cleanup attempt {attempt + 1} failed: {e}")
            if attempt < cleanup_attempts - 1:
                await asyncio.sleep(3)
    
    logger.info("Waiting for complete cleanup...")
    await asyncio.sleep(5)  # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø–∞—É–∑–∞ –¥–ª—è –ø–æ–ª–Ω–æ–π –æ—á–∏—Å—Ç–∫–∏
    
    # –ó–∞–ø—É—Å–∫ polling —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º retry –º–µ—Ö–∞–Ω–∏–∑–º–æ–º
    max_retries = 5
    for attempt in range(max_retries):
        try:
            logger.info(f"Starting polling (attempt {attempt + 1}/{max_retries})...")
            
            # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –ø–µ—Ä–µ–¥ –∫–∞–∂–¥–æ–π –ø–æ–ø—ã—Ç–∫–æ–π
            if attempt > 0:
                logger.info("Additional cleanup before retry...")
                try:
                    await application.bot.delete_webhook(drop_pending_updates=True)
                    await asyncio.sleep(2)
                except:
                    pass
            
            await application.updater.start_polling(
                allowed_updates=Update.ALL_TYPES, 
                drop_pending_updates=True,
                timeout=45,
                pool_timeout=45,
                connect_timeout=30,
                read_timeout=30
            )
            logger.info("Polling started successfully")
            break
        except Exception as e:
            logger.error(f"Polling failed on attempt {attempt + 1}: {e}")
            if attempt < max_retries - 1:
                wait_time = (attempt + 1) * 15  # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è
                logger.info(f"Waiting {wait_time} seconds before retry...")
                await asyncio.sleep(wait_time)
            else:
                logger.error("All polling attempts failed - this indicates a serious configuration issue")
                logger.error("Possible causes:")
                logger.error("1. Bot token is being used by another instance")
                logger.error("2. Webhook is set externally")
                logger.error("3. Network connectivity issues")
                return
    
    # –ü–æ–¥–¥–µ—Ä–∂–∞–Ω–∏–µ —Ä–∞–±–æ—Ç—ã
    try:
        logger.info("Bot is now running and waiting for messages...")
        await asyncio.Event().wait()
    except KeyboardInterrupt:
        logger.info("Stopping bot...")
    finally:
        await application.stop()

async def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    logger.info("Starting Gemini Telegram Bot...")
    
    # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –¥–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
    await asyncio.sleep(1)
    
    # –ó–∞–ø—É—Å–∫ HTTP —Å–µ—Ä–≤–µ—Ä–∞, –±–æ—Ç–∞ –∏ watchdog –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
    try:
        logger.info("üöÄ Starting all services: HTTP server + Bot + Watchdog...")
        await asyncio.gather(
            start_server(),
            run_bot(),
            watchdog()
        )
    except Exception as e:
        logger.error(f"Critical error in main: {e}")
        # –ü–æ–ø—ã—Ç–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ —á–µ—Ä–µ–∑ 30 —Å–µ–∫—É–Ω–¥
        logger.info("Attempting restart in 30 seconds...")
        await asyncio.sleep(30)
        raise

if __name__ == '__main__':
    asyncio.run(main()) 